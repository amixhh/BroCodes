"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/y-codemirror";
exports.ids = ["vendor-chunks/y-codemirror"];
exports.modules = {

/***/ "(ssr)/./node_modules/y-codemirror/src/y-codemirror.js":
/*!*******************************************************!*\
  !*** ./node_modules/y-codemirror/src/y-codemirror.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CodeMirrorBinding: () => (/* binding */ CodeMirrorBinding),\n/* harmony export */   CodemirrorBinding: () => (/* binding */ CodemirrorBinding),\n/* harmony export */   cmOrigin: () => (/* binding */ cmOrigin)\n/* harmony export */ });\n/* harmony import */ var lib0_mutex__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lib0/mutex */ \"(ssr)/./node_modules/lib0/mutex.js\");\n/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/math */ \"(ssr)/./node_modules/lib0/math.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var lib0_function__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/function */ \"(ssr)/./node_modules/lib0/function.js\");\n/* harmony import */ var lib0_eventloop__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lib0/eventloop */ \"(ssr)/./node_modules/lib0/eventloop.js\");\n/* harmony import */ var lib0_observable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/observable */ \"(ssr)/./node_modules/lib0/observable.js\");\n/* harmony import */ var lib0_diff__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/diff */ \"(ssr)/./node_modules/lib0/diff.js\");\n/* harmony import */ var codemirror__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! codemirror */ \"(ssr)/./node_modules/codemirror/lib/codemirror.js\");\n/**\n * @module bindings/textarea\n */\n\n\n\n\n\n\n\n\n\n\nconst cmOrigin = 'y-codemirror'\n\n/**\n * @param {CodemirrorBinding} binding\n * @param {any} event\n */\nconst typeObserver = (binding, event) => {\n  binding._mux(() => {\n    const cmDoc = binding.cmDoc\n    const cm = cmDoc.getEditor()\n    // Normally the position is right-associated\n    // But when remote changes happen, it looks like the remote user is hijacking your position.\n    // Just for remote insertions, we make the collapsed cursor left-associated.\n    // If selection is not collapsed, we only make \"to\" left associated\n    let anchor = cm.indexFromPos(cm.getCursor('anchor'))\n    let head = cm.indexFromPos(cm.getCursor('head'))\n    const switchSel = head < anchor\n    // normalize selection so that anchor < head, switch back later\n    if (switchSel) {\n      const tmp = head\n      head = anchor\n      anchor = tmp\n    }\n    const performChange = () => {\n      const delta = event.delta\n      let index = 0\n      for (let i = 0; i < event.delta.length; i++) {\n        const d = delta[i]\n        if (d.retain) {\n          index += d.retain\n        } else if (d.insert) {\n          if (index < anchor || (anchor < head && index === anchor)) {\n            anchor += d.insert.length\n          }\n          if (index < head) {\n            head += d.insert.length\n          }\n          const pos = cmDoc.posFromIndex(index)\n          cmDoc.replaceRange(d.insert, pos, pos, cmOrigin)\n          index += d.insert.length\n        } else if (d.delete) {\n          if (index < anchor) {\n            anchor = lib0_math__WEBPACK_IMPORTED_MODULE_1__.max(anchor - d.delete, index)\n          }\n          if (index < head) {\n            head = lib0_math__WEBPACK_IMPORTED_MODULE_1__.max(head - d.delete, index)\n          }\n          const start = cmDoc.posFromIndex(index)\n          const end = cmDoc.posFromIndex(index + d.delete)\n          cmDoc.replaceRange('', start, end, cmOrigin)\n        }\n      }\n    }\n    // if possible, bundle the changes using cm.operation\n    if (cm) {\n      cm.operation(performChange)\n    } else {\n      performChange()\n    }\n    if (switchSel) {\n      const tmp = head\n      head = anchor\n      anchor = tmp\n    }\n    cm.setSelection(cm.posFromIndex(anchor), cm.posFromIndex(head), { scroll: false })\n  })\n}\n\n/**\n * @param {CodemirrorBinding} binding\n * @param {Array<any>} changes\n */\nconst targetObserver = (binding, changes) => {\n  binding._mux(() => {\n    binding.doc.transact(() => {\n      const hasPaste = binding.yUndoManager && changes.some(change => change.origin === 'paste')\n      if (hasPaste) {\n        binding.yUndoManager.stopCapturing()\n      }\n\n      if (changes.length > 1) {\n        // If there are several consecutive changes, we can't reliably compute the positions anymore. See y-codemirror#11\n        // Instead, we will compute the diff and apply the changes\n        const d = lib0_diff__WEBPACK_IMPORTED_MODULE_2__.simpleDiffString(binding.type.toString(), binding.cmDoc.getValue())\n        binding.type.delete(d.index, d.remove)\n        binding.type.insert(d.index, d.insert)\n      } else {\n        const change = changes[0]\n        const start = binding.cmDoc.indexFromPos(change.from)\n        const delLen = change.removed.map(s => s.length).reduce(lib0_math__WEBPACK_IMPORTED_MODULE_1__.add) + change.removed.length - 1\n        if (delLen > 0) {\n          binding.type.delete(start, delLen)\n        }\n        if (change.text.length > 0) {\n          binding.type.insert(start, change.text.join('\\n'))\n        }\n      }\n\n      if (hasPaste) {\n        binding.yUndoManager.stopCapturing()\n      }\n    }, binding)\n  })\n  if (binding._pendingCursorEvent) {\n    binding._pendingCursorEvent = false\n    binding.emit('cursorActivity', [binding])\n  }\n}\n\nconst createRemoteCaret = (username, color) => {\n  const caret = document.createElement('span')\n  caret.classList.add('remote-caret')\n  caret.setAttribute('style', `border-color: ${color}`)\n  const userDiv = document.createElement('div')\n  userDiv.setAttribute('style', `background-color: ${color}`)\n  userDiv.insertBefore(document.createTextNode(username), null)\n  caret.insertBefore(userDiv, null)\n  setTimeout(() => {\n    caret.classList.add('hide-name')\n  }, 2000)\n  return caret\n}\n\nconst createEmptyLinePlaceholder = (color) => {\n  const placeholder = document.createElement('span')\n  placeholder.setAttribute('style', 'user-select: none;')\n  const emptyTxt = document.createElement('span')\n  emptyTxt.insertBefore(document.createTextNode(''), null)\n  const sel = document.createElement('span')\n  sel.setAttribute('class', 'y-line-selection')\n  sel.setAttribute('style', `display: inline-block; position: absolute; left: 4px; right: 4px; top: 0; bottom: 0; background-color: ${color}70`)\n  placeholder.insertBefore(sel, null)\n  placeholder.insertBefore(emptyTxt, null)\n  return placeholder\n}\n\nconst updateRemoteSelection = (y, cm, type, cursors, clientId, awareness) => {\n  // redraw caret and selection for clientId\n  const aw = awareness.getStates().get(clientId)\n  // destroy current text mark\n  const m = cursors.get(clientId)\n  if (m !== undefined) {\n    if (m.caret) {\n      m.caret.clear()\n    }\n    m.sel.forEach(sel => sel.clear())\n    cursors.delete(clientId)\n  }\n  if (aw === undefined) {\n    return\n  }\n  const user = aw.user || {}\n  if (user.color == null) {\n    user.color = '#ffa500'\n  }\n  if (user.name == null) {\n    user.name = `User: ${clientId}`\n  }\n  const cursor = aw.cursor\n  if (cursor == null || cursor.anchor == null || cursor.head == null) {\n    return\n  }\n  const anchor = yjs__WEBPACK_IMPORTED_MODULE_3__.createAbsolutePositionFromRelativePosition(JSON.parse(cursor.anchor), y)\n  const head = yjs__WEBPACK_IMPORTED_MODULE_3__.createAbsolutePositionFromRelativePosition(JSON.parse(cursor.head), y)\n  if (anchor !== null && head !== null && anchor.type === type && head.type === type) {\n    const headpos = cm.posFromIndex(head.index)\n    const anchorpos = cm.posFromIndex(anchor.index)\n    let from, to\n    if (head.index < anchor.index) {\n      from = headpos\n      to = anchorpos\n    } else {\n      from = anchorpos\n      to = headpos\n    }\n    const caretEl = createRemoteCaret(user.name, user.color)\n    // if position was \"relatively\" the same, do not show name again and hide instead\n    if (m && lib0_function__WEBPACK_IMPORTED_MODULE_4__.equalityFlat(aw.cursor.anchor, m.awCursor.anchor) && lib0_function__WEBPACK_IMPORTED_MODULE_4__.equalityFlat(aw.cursor.head, m.awCursor.head)) {\n      caretEl.classList.add('hide-name')\n    }\n    const sel = []\n\n    if (head.index !== anchor.index) {\n      if (from.line !== to.line && from.ch !== 0) {\n        // start of selection will only be a simple text-selection\n        sel.push(cm.markText(from, new codemirror__WEBPACK_IMPORTED_MODULE_0__.Pos(from.line + 1, 0), { css: `background-color: ${user.color}70;`, inclusiveRight: false, inclusiveLeft: false }))\n        from = new codemirror__WEBPACK_IMPORTED_MODULE_0__.Pos(from.line + 1, 0)\n      }\n      while (from.line !== to.line) {\n        // middle of selection is always a whole-line selection. We add a widget at the first position which will fill the background.\n        sel.push(cm.setBookmark(new codemirror__WEBPACK_IMPORTED_MODULE_0__.Pos(from.line, 0), { widget: createEmptyLinePlaceholder(user.color) }))\n        from = new codemirror__WEBPACK_IMPORTED_MODULE_0__.Pos(from.line + 1, 0)\n      }\n      sel.push(cm.markText(from, to, { css: `background-color: ${user.color}70;`, inclusiveRight: false, inclusiveLeft: false }))\n    }\n    // only render caret if not the complete last line was selected (in this case headpos.ch === 0)\n    const caret = sel.length > 0 && to === headpos && headpos.ch === 0 ? null : cm.setBookmark(headpos, { widget: caretEl, insertLeft: true })\n    cursors.set(clientId, { caret, sel, awCursor: cursor })\n  }\n}\n\nconst codemirrorCursorActivity = (y, cm, type, awareness) => {\n  const aw = awareness.getLocalState()\n  if (!cm.hasFocus() || aw == null || !cm.display.wrapper.ownerDocument.hasFocus()) {\n    return\n  }\n  const newAnchor = yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromTypeIndex(type, cm.indexFromPos(cm.getCursor('anchor')))\n  const newHead = yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromTypeIndex(type, cm.indexFromPos(cm.getCursor('head')))\n  let currentAnchor = null\n  let currentHead = null\n  if (aw.cursor != null) {\n    currentAnchor = yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromJSON(JSON.parse(aw.cursor.anchor))\n    currentHead = yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromJSON(JSON.parse(aw.cursor.head))\n  }\n  if (aw.cursor == null || !yjs__WEBPACK_IMPORTED_MODULE_3__.compareRelativePositions(currentAnchor, newAnchor) || !yjs__WEBPACK_IMPORTED_MODULE_3__.compareRelativePositions(currentHead, newHead)) {\n    awareness.setLocalStateField('cursor', {\n      anchor: JSON.stringify(newAnchor),\n      head: JSON.stringify(newHead)\n    })\n  }\n}\n\n/**\n * A binding that binds a YText to a CodeMirror editor.\n *\n * @example\n *   const ytext = ydocument.define('codemirror', Y.Text)\n *   const editor = new CodeMirror(document.querySelector('#container'), {\n *     mode: 'javascript',\n *     lineNumbers: true\n *   })\n *   const binding = new CodemirrorBinding(ytext, editor)\n *\n */\nclass CodemirrorBinding extends lib0_observable__WEBPACK_IMPORTED_MODULE_5__.Observable {\n  /**\n   * @param {Y.Text} textType\n   * @param {import('codemirror').Editor} codeMirror\n   * @param {any | null} [awareness]\n   * @param {{ yUndoManager?: Y.UndoManager }} [options]\n   */\n  constructor (textType, codeMirror, awareness = null, { yUndoManager = null } = {}) {\n    super()\n    const doc = textType.doc\n    const cmDoc = codeMirror.getDoc()\n    this.doc = doc\n    this.type = textType\n    this.cm = codeMirror\n    this.cmDoc = cmDoc\n    this.awareness = awareness || null\n    this.yUndoManager = yUndoManager\n    this._onStackItemAdded = ({ stackItem, changedParentTypes }) => {\n      // only store metadata if this type was affected\n      if (changedParentTypes.has(textType) && this._beforeChangeSelection) {\n        stackItem.meta.set(this, this._beforeChangeSelection)\n      }\n    }\n    this._onStackItemPopped = ({ stackItem }) => {\n      const sel = stackItem.meta.get(this)\n      if (sel) {\n        const anchor = yjs__WEBPACK_IMPORTED_MODULE_3__.createAbsolutePositionFromRelativePosition(sel.anchor, doc).index\n        const head = yjs__WEBPACK_IMPORTED_MODULE_3__.createAbsolutePositionFromRelativePosition(sel.head, doc).index\n        codeMirror.setSelection(codeMirror.posFromIndex(anchor), codeMirror.posFromIndex(head))\n        this._beforeChange()\n      }\n    }\n    if (yUndoManager) {\n      yUndoManager.trackedOrigins.add(this) // track changes performed by this editor binding\n      const editorUndo = cm => {\n        // Keymaps always start with an active operation.\n        // End the current operation so that the event is fired at the correct moment.\n        // @todo check cm.curOp in typeListener and endOperation always.\n        cm.endOperation()\n        yUndoManager.undo()\n        cm.startOperation()\n      }\n      const editorRedo = cm => {\n        cm.endOperation()\n        yUndoManager.redo()\n        cm.startOperation()\n      }\n      codeMirror.addKeyMap({\n        // pc\n        'Ctrl-Z': editorUndo,\n        'Shift-Ctrl-Z': editorRedo,\n        'Ctrl-Y': editorRedo,\n        // mac\n        'Cmd-Z': editorUndo,\n        'Shift-Cmd-Z': editorRedo,\n        'Cmd-Y': editorRedo\n      })\n\n      yUndoManager.on('stack-item-added', this._onStackItemAdded)\n      yUndoManager.on('stack-item-popped', this._onStackItemPopped)\n    }\n\n    this._mux = (0,lib0_mutex__WEBPACK_IMPORTED_MODULE_6__.createMutex)()\n    // set initial value\n    cmDoc.setValue(textType.toString())\n    // observe type and target\n    this._typeObserver = event => typeObserver(this, event)\n    this._targetObserver = (instance, changes) => {\n      if (instance.getDoc() === cmDoc) {\n        targetObserver(this, changes)\n      }\n    }\n    this._cursors = new Map()\n    this._changedCursors = new Set()\n    this._debounceCursorEvent = lib0_eventloop__WEBPACK_IMPORTED_MODULE_7__.createDebouncer(10)\n    this._awarenessListener = event => {\n      if (codeMirror.getDoc() !== cmDoc) {\n        return\n      }\n      const f = clientId => {\n        if (clientId !== doc.clientID) {\n          this._changedCursors.add(clientId)\n        }\n      }\n      event.added.forEach(f)\n      event.removed.forEach(f)\n      event.updated.forEach(f)\n      if (this._changedCursors.size > 0) {\n        this._debounceCursorEvent(() => {\n          this._changedCursors.forEach(clientId => {\n            updateRemoteSelection(doc, codeMirror, textType, this._cursors, clientId, awareness)\n          })\n          this._changedCursors.clear()\n        })\n      }\n    }\n    this._pendingCursorEvent = false\n    this._cursorListener = () => {\n      if (codeMirror.getDoc() === cmDoc) {\n        this._pendingCursorEvent = true\n        setTimeout(() => {\n          if (this._pendingCursorEvent) {\n            this._pendingCursorEvent = false\n            this.emit('cursorActivity', [codeMirror])\n          }\n        }, 0)\n      }\n    }\n    this.on('cursorActivity', () => {\n      codemirrorCursorActivity(doc, codeMirror, textType, awareness)\n    })\n    this._blurListeer = () => awareness.setLocalStateField('cursor', null)\n\n    textType.observe(this._typeObserver)\n    // @ts-ignore\n    codeMirror.on('changes', this._targetObserver)\n    /**\n     * @type {{ anchor: Y.RelativePosition, head: Y.RelativePosition } | null}\n     */\n    this._beforeChangeSelection = null\n    this._beforeChange = () => {\n      // update the the beforeChangeSelection that is stored befor each change to the editor (except when applying remote changes)\n      this._mux(() => {\n        // store the selection before the change is applied so we can restore it with the undo manager.\n        const anchor = yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromTypeIndex(textType, codeMirror.indexFromPos(codeMirror.getCursor('anchor')))\n        const head = yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromTypeIndex(textType, codeMirror.indexFromPos(codeMirror.getCursor('head')))\n        this._beforeChangeSelection = { anchor, head }\n      })\n    }\n    codeMirror.on('beforeChange', this._beforeChange)\n    if (awareness) {\n      codeMirror.on('swapDoc', this._blurListeer)\n      awareness.on('change', this._awarenessListener)\n      // @ts-ignore\n      codeMirror.on('cursorActivity', this._cursorListener)\n      codeMirror.on('blur', this._blurListeer)\n      codeMirror.on('focus', this._cursorListener)\n    }\n  }\n\n  destroy () {\n    this.type.unobserve(this._typeObserver)\n    this.cm.off('swapDoc', this._blurListeer)\n    // @ts-ignore\n    this.cm.off('changes', this._targetObserver)\n    this.cm.off('beforeChange', this._beforeChange)\n    // @ts-ignore\n    this.cm.off('cursorActivity', this._cursorListener)\n    this.cm.off('focus', this._cursorListener)\n    this.cm.off('blur', this._blurListeer)\n    if (this.awareness) {\n      this.awareness.off('change', this._awarenessListener)\n    }\n    if (this.yUndoManager) {\n      this.yUndoManager.off('stack-item-added', this._onStackItemAdded)\n      this.yUndoManager.off('stack-item-popped', this._onStackItemPopped)\n      this.yUndoManager.trackedOrigins.delete(this)\n    }\n    this.type = null\n    this.cm = null\n    this.cmDoc = null\n    super.destroy()\n  }\n}\n\nconst CodeMirrorBinding = CodemirrorBinding\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1jb2RlbWlycm9yL3NyYy95LWNvZGVtaXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRXdDO0FBQ1A7QUFDVDtBQUNhO0FBQ007QUFDQztBQUNYO0FBQ0U7O0FBRTVCOztBQUVQO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHFCQUFxQiwwQ0FBUTtBQUM3QjtBQUNBO0FBQ0EsbUJBQW1CLDBDQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGVBQWU7QUFDckYsR0FBRztBQUNIOztBQUVBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVEQUFxQjtBQUN2QztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxnRUFBZ0UsMENBQVE7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxNQUFNO0FBQ3JEO0FBQ0EscURB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QSx1QkFBdUIsb0VBQXFDO0FBQzVELHFCQUFxQixvRUFBcUM7QUFDMUQsd0NBQXdDO0FBQ3hDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWx0aW1lLWNvZGUtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL3ktY29kZW1pcnJvci9zcmMveS1jb2RlbWlycm9yLmpzPzk5NTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIGJpbmRpbmdzL3RleHRhcmVhXG4gKi9cblxuaW1wb3J0IHsgY3JlYXRlTXV0ZXggfSBmcm9tICdsaWIwL211dGV4J1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICdsaWIwL21hdGgnXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcbmltcG9ydCAqIGFzIGZ1bmMgZnJvbSAnbGliMC9mdW5jdGlvbidcbmltcG9ydCAqIGFzIGV2ZW50bG9vcCBmcm9tICdsaWIwL2V2ZW50bG9vcCdcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdsaWIwL29ic2VydmFibGUnXG5pbXBvcnQgKiBhcyBkaWZmIGZyb20gJ2xpYjAvZGlmZidcbmltcG9ydCBDb2RlTWlycm9yIGZyb20gJ2NvZGVtaXJyb3InXG5cbmV4cG9ydCBjb25zdCBjbU9yaWdpbiA9ICd5LWNvZGVtaXJyb3InXG5cbi8qKlxuICogQHBhcmFtIHtDb2RlbWlycm9yQmluZGluZ30gYmluZGluZ1xuICogQHBhcmFtIHthbnl9IGV2ZW50XG4gKi9cbmNvbnN0IHR5cGVPYnNlcnZlciA9IChiaW5kaW5nLCBldmVudCkgPT4ge1xuICBiaW5kaW5nLl9tdXgoKCkgPT4ge1xuICAgIGNvbnN0IGNtRG9jID0gYmluZGluZy5jbURvY1xuICAgIGNvbnN0IGNtID0gY21Eb2MuZ2V0RWRpdG9yKClcbiAgICAvLyBOb3JtYWxseSB0aGUgcG9zaXRpb24gaXMgcmlnaHQtYXNzb2NpYXRlZFxuICAgIC8vIEJ1dCB3aGVuIHJlbW90ZSBjaGFuZ2VzIGhhcHBlbiwgaXQgbG9va3MgbGlrZSB0aGUgcmVtb3RlIHVzZXIgaXMgaGlqYWNraW5nIHlvdXIgcG9zaXRpb24uXG4gICAgLy8gSnVzdCBmb3IgcmVtb3RlIGluc2VydGlvbnMsIHdlIG1ha2UgdGhlIGNvbGxhcHNlZCBjdXJzb3IgbGVmdC1hc3NvY2lhdGVkLlxuICAgIC8vIElmIHNlbGVjdGlvbiBpcyBub3QgY29sbGFwc2VkLCB3ZSBvbmx5IG1ha2UgXCJ0b1wiIGxlZnQgYXNzb2NpYXRlZFxuICAgIGxldCBhbmNob3IgPSBjbS5pbmRleEZyb21Qb3MoY20uZ2V0Q3Vyc29yKCdhbmNob3InKSlcbiAgICBsZXQgaGVhZCA9IGNtLmluZGV4RnJvbVBvcyhjbS5nZXRDdXJzb3IoJ2hlYWQnKSlcbiAgICBjb25zdCBzd2l0Y2hTZWwgPSBoZWFkIDwgYW5jaG9yXG4gICAgLy8gbm9ybWFsaXplIHNlbGVjdGlvbiBzbyB0aGF0IGFuY2hvciA8IGhlYWQsIHN3aXRjaCBiYWNrIGxhdGVyXG4gICAgaWYgKHN3aXRjaFNlbCkge1xuICAgICAgY29uc3QgdG1wID0gaGVhZFxuICAgICAgaGVhZCA9IGFuY2hvclxuICAgICAgYW5jaG9yID0gdG1wXG4gICAgfVxuICAgIGNvbnN0IHBlcmZvcm1DaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBjb25zdCBkZWx0YSA9IGV2ZW50LmRlbHRhXG4gICAgICBsZXQgaW5kZXggPSAwXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50LmRlbHRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGQgPSBkZWx0YVtpXVxuICAgICAgICBpZiAoZC5yZXRhaW4pIHtcbiAgICAgICAgICBpbmRleCArPSBkLnJldGFpblxuICAgICAgICB9IGVsc2UgaWYgKGQuaW5zZXJ0KSB7XG4gICAgICAgICAgaWYgKGluZGV4IDwgYW5jaG9yIHx8IChhbmNob3IgPCBoZWFkICYmIGluZGV4ID09PSBhbmNob3IpKSB7XG4gICAgICAgICAgICBhbmNob3IgKz0gZC5pbnNlcnQubGVuZ3RoXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmRleCA8IGhlYWQpIHtcbiAgICAgICAgICAgIGhlYWQgKz0gZC5pbnNlcnQubGVuZ3RoXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHBvcyA9IGNtRG9jLnBvc0Zyb21JbmRleChpbmRleClcbiAgICAgICAgICBjbURvYy5yZXBsYWNlUmFuZ2UoZC5pbnNlcnQsIHBvcywgcG9zLCBjbU9yaWdpbilcbiAgICAgICAgICBpbmRleCArPSBkLmluc2VydC5sZW5ndGhcbiAgICAgICAgfSBlbHNlIGlmIChkLmRlbGV0ZSkge1xuICAgICAgICAgIGlmIChpbmRleCA8IGFuY2hvcikge1xuICAgICAgICAgICAgYW5jaG9yID0gbWF0aC5tYXgoYW5jaG9yIC0gZC5kZWxldGUsIGluZGV4KVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5kZXggPCBoZWFkKSB7XG4gICAgICAgICAgICBoZWFkID0gbWF0aC5tYXgoaGVhZCAtIGQuZGVsZXRlLCBpbmRleClcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc3RhcnQgPSBjbURvYy5wb3NGcm9tSW5kZXgoaW5kZXgpXG4gICAgICAgICAgY29uc3QgZW5kID0gY21Eb2MucG9zRnJvbUluZGV4KGluZGV4ICsgZC5kZWxldGUpXG4gICAgICAgICAgY21Eb2MucmVwbGFjZVJhbmdlKCcnLCBzdGFydCwgZW5kLCBjbU9yaWdpbilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBwb3NzaWJsZSwgYnVuZGxlIHRoZSBjaGFuZ2VzIHVzaW5nIGNtLm9wZXJhdGlvblxuICAgIGlmIChjbSkge1xuICAgICAgY20ub3BlcmF0aW9uKHBlcmZvcm1DaGFuZ2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIHBlcmZvcm1DaGFuZ2UoKVxuICAgIH1cbiAgICBpZiAoc3dpdGNoU2VsKSB7XG4gICAgICBjb25zdCB0bXAgPSBoZWFkXG4gICAgICBoZWFkID0gYW5jaG9yXG4gICAgICBhbmNob3IgPSB0bXBcbiAgICB9XG4gICAgY20uc2V0U2VsZWN0aW9uKGNtLnBvc0Zyb21JbmRleChhbmNob3IpLCBjbS5wb3NGcm9tSW5kZXgoaGVhZCksIHsgc2Nyb2xsOiBmYWxzZSB9KVxuICB9KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29kZW1pcnJvckJpbmRpbmd9IGJpbmRpbmdcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gY2hhbmdlc1xuICovXG5jb25zdCB0YXJnZXRPYnNlcnZlciA9IChiaW5kaW5nLCBjaGFuZ2VzKSA9PiB7XG4gIGJpbmRpbmcuX211eCgoKSA9PiB7XG4gICAgYmluZGluZy5kb2MudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgY29uc3QgaGFzUGFzdGUgPSBiaW5kaW5nLnlVbmRvTWFuYWdlciAmJiBjaGFuZ2VzLnNvbWUoY2hhbmdlID0+IGNoYW5nZS5vcmlnaW4gPT09ICdwYXN0ZScpXG4gICAgICBpZiAoaGFzUGFzdGUpIHtcbiAgICAgICAgYmluZGluZy55VW5kb01hbmFnZXIuc3RvcENhcHR1cmluZygpXG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIHNldmVyYWwgY29uc2VjdXRpdmUgY2hhbmdlcywgd2UgY2FuJ3QgcmVsaWFibHkgY29tcHV0ZSB0aGUgcG9zaXRpb25zIGFueW1vcmUuIFNlZSB5LWNvZGVtaXJyb3IjMTFcbiAgICAgICAgLy8gSW5zdGVhZCwgd2Ugd2lsbCBjb21wdXRlIHRoZSBkaWZmIGFuZCBhcHBseSB0aGUgY2hhbmdlc1xuICAgICAgICBjb25zdCBkID0gZGlmZi5zaW1wbGVEaWZmU3RyaW5nKGJpbmRpbmcudHlwZS50b1N0cmluZygpLCBiaW5kaW5nLmNtRG9jLmdldFZhbHVlKCkpXG4gICAgICAgIGJpbmRpbmcudHlwZS5kZWxldGUoZC5pbmRleCwgZC5yZW1vdmUpXG4gICAgICAgIGJpbmRpbmcudHlwZS5pbnNlcnQoZC5pbmRleCwgZC5pbnNlcnQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSBjaGFuZ2VzWzBdXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gYmluZGluZy5jbURvYy5pbmRleEZyb21Qb3MoY2hhbmdlLmZyb20pXG4gICAgICAgIGNvbnN0IGRlbExlbiA9IGNoYW5nZS5yZW1vdmVkLm1hcChzID0+IHMubGVuZ3RoKS5yZWR1Y2UobWF0aC5hZGQpICsgY2hhbmdlLnJlbW92ZWQubGVuZ3RoIC0gMVxuICAgICAgICBpZiAoZGVsTGVuID4gMCkge1xuICAgICAgICAgIGJpbmRpbmcudHlwZS5kZWxldGUoc3RhcnQsIGRlbExlbilcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlLnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGJpbmRpbmcudHlwZS5pbnNlcnQoc3RhcnQsIGNoYW5nZS50ZXh0LmpvaW4oJ1xcbicpKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNQYXN0ZSkge1xuICAgICAgICBiaW5kaW5nLnlVbmRvTWFuYWdlci5zdG9wQ2FwdHVyaW5nKClcbiAgICAgIH1cbiAgICB9LCBiaW5kaW5nKVxuICB9KVxuICBpZiAoYmluZGluZy5fcGVuZGluZ0N1cnNvckV2ZW50KSB7XG4gICAgYmluZGluZy5fcGVuZGluZ0N1cnNvckV2ZW50ID0gZmFsc2VcbiAgICBiaW5kaW5nLmVtaXQoJ2N1cnNvckFjdGl2aXR5JywgW2JpbmRpbmddKVxuICB9XG59XG5cbmNvbnN0IGNyZWF0ZVJlbW90ZUNhcmV0ID0gKHVzZXJuYW1lLCBjb2xvcikgPT4ge1xuICBjb25zdCBjYXJldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICBjYXJldC5jbGFzc0xpc3QuYWRkKCdyZW1vdGUtY2FyZXQnKVxuICBjYXJldC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgYGJvcmRlci1jb2xvcjogJHtjb2xvcn1gKVxuICBjb25zdCB1c2VyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgdXNlckRpdi5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgYGJhY2tncm91bmQtY29sb3I6ICR7Y29sb3J9YClcbiAgdXNlckRpdi5pbnNlcnRCZWZvcmUoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodXNlcm5hbWUpLCBudWxsKVxuICBjYXJldC5pbnNlcnRCZWZvcmUodXNlckRpdiwgbnVsbClcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgY2FyZXQuY2xhc3NMaXN0LmFkZCgnaGlkZS1uYW1lJylcbiAgfSwgMjAwMClcbiAgcmV0dXJuIGNhcmV0XG59XG5cbmNvbnN0IGNyZWF0ZUVtcHR5TGluZVBsYWNlaG9sZGVyID0gKGNvbG9yKSA9PiB7XG4gIGNvbnN0IHBsYWNlaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gIHBsYWNlaG9sZGVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAndXNlci1zZWxlY3Q6IG5vbmU7JylcbiAgY29uc3QgZW1wdHlUeHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgZW1wdHlUeHQuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKSwgbnVsbClcbiAgY29uc3Qgc2VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gIHNlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3ktbGluZS1zZWxlY3Rpb24nKVxuICBzZWwuc2V0QXR0cmlidXRlKCdzdHlsZScsIGBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogNHB4OyByaWdodDogNHB4OyB0b3A6IDA7IGJvdHRvbTogMDsgYmFja2dyb3VuZC1jb2xvcjogJHtjb2xvcn03MGApXG4gIHBsYWNlaG9sZGVyLmluc2VydEJlZm9yZShzZWwsIG51bGwpXG4gIHBsYWNlaG9sZGVyLmluc2VydEJlZm9yZShlbXB0eVR4dCwgbnVsbClcbiAgcmV0dXJuIHBsYWNlaG9sZGVyXG59XG5cbmNvbnN0IHVwZGF0ZVJlbW90ZVNlbGVjdGlvbiA9ICh5LCBjbSwgdHlwZSwgY3Vyc29ycywgY2xpZW50SWQsIGF3YXJlbmVzcykgPT4ge1xuICAvLyByZWRyYXcgY2FyZXQgYW5kIHNlbGVjdGlvbiBmb3IgY2xpZW50SWRcbiAgY29uc3QgYXcgPSBhd2FyZW5lc3MuZ2V0U3RhdGVzKCkuZ2V0KGNsaWVudElkKVxuICAvLyBkZXN0cm95IGN1cnJlbnQgdGV4dCBtYXJrXG4gIGNvbnN0IG0gPSBjdXJzb3JzLmdldChjbGllbnRJZClcbiAgaWYgKG0gIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChtLmNhcmV0KSB7XG4gICAgICBtLmNhcmV0LmNsZWFyKClcbiAgICB9XG4gICAgbS5zZWwuZm9yRWFjaChzZWwgPT4gc2VsLmNsZWFyKCkpXG4gICAgY3Vyc29ycy5kZWxldGUoY2xpZW50SWQpXG4gIH1cbiAgaWYgKGF3ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCB1c2VyID0gYXcudXNlciB8fCB7fVxuICBpZiAodXNlci5jb2xvciA9PSBudWxsKSB7XG4gICAgdXNlci5jb2xvciA9ICcjZmZhNTAwJ1xuICB9XG4gIGlmICh1c2VyLm5hbWUgPT0gbnVsbCkge1xuICAgIHVzZXIubmFtZSA9IGBVc2VyOiAke2NsaWVudElkfWBcbiAgfVxuICBjb25zdCBjdXJzb3IgPSBhdy5jdXJzb3JcbiAgaWYgKGN1cnNvciA9PSBudWxsIHx8IGN1cnNvci5hbmNob3IgPT0gbnVsbCB8fCBjdXJzb3IuaGVhZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgYW5jaG9yID0gWS5jcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24oSlNPTi5wYXJzZShjdXJzb3IuYW5jaG9yKSwgeSlcbiAgY29uc3QgaGVhZCA9IFkuY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uKEpTT04ucGFyc2UoY3Vyc29yLmhlYWQpLCB5KVxuICBpZiAoYW5jaG9yICE9PSBudWxsICYmIGhlYWQgIT09IG51bGwgJiYgYW5jaG9yLnR5cGUgPT09IHR5cGUgJiYgaGVhZC50eXBlID09PSB0eXBlKSB7XG4gICAgY29uc3QgaGVhZHBvcyA9IGNtLnBvc0Zyb21JbmRleChoZWFkLmluZGV4KVxuICAgIGNvbnN0IGFuY2hvcnBvcyA9IGNtLnBvc0Zyb21JbmRleChhbmNob3IuaW5kZXgpXG4gICAgbGV0IGZyb20sIHRvXG4gICAgaWYgKGhlYWQuaW5kZXggPCBhbmNob3IuaW5kZXgpIHtcbiAgICAgIGZyb20gPSBoZWFkcG9zXG4gICAgICB0byA9IGFuY2hvcnBvc1xuICAgIH0gZWxzZSB7XG4gICAgICBmcm9tID0gYW5jaG9ycG9zXG4gICAgICB0byA9IGhlYWRwb3NcbiAgICB9XG4gICAgY29uc3QgY2FyZXRFbCA9IGNyZWF0ZVJlbW90ZUNhcmV0KHVzZXIubmFtZSwgdXNlci5jb2xvcilcbiAgICAvLyBpZiBwb3NpdGlvbiB3YXMgXCJyZWxhdGl2ZWx5XCIgdGhlIHNhbWUsIGRvIG5vdCBzaG93IG5hbWUgYWdhaW4gYW5kIGhpZGUgaW5zdGVhZFxuICAgIGlmIChtICYmIGZ1bmMuZXF1YWxpdHlGbGF0KGF3LmN1cnNvci5hbmNob3IsIG0uYXdDdXJzb3IuYW5jaG9yKSAmJiBmdW5jLmVxdWFsaXR5RmxhdChhdy5jdXJzb3IuaGVhZCwgbS5hd0N1cnNvci5oZWFkKSkge1xuICAgICAgY2FyZXRFbC5jbGFzc0xpc3QuYWRkKCdoaWRlLW5hbWUnKVxuICAgIH1cbiAgICBjb25zdCBzZWwgPSBbXVxuXG4gICAgaWYgKGhlYWQuaW5kZXggIT09IGFuY2hvci5pbmRleCkge1xuICAgICAgaWYgKGZyb20ubGluZSAhPT0gdG8ubGluZSAmJiBmcm9tLmNoICE9PSAwKSB7XG4gICAgICAgIC8vIHN0YXJ0IG9mIHNlbGVjdGlvbiB3aWxsIG9ubHkgYmUgYSBzaW1wbGUgdGV4dC1zZWxlY3Rpb25cbiAgICAgICAgc2VsLnB1c2goY20ubWFya1RleHQoZnJvbSwgbmV3IENvZGVNaXJyb3IuUG9zKGZyb20ubGluZSArIDEsIDApLCB7IGNzczogYGJhY2tncm91bmQtY29sb3I6ICR7dXNlci5jb2xvcn03MDtgLCBpbmNsdXNpdmVSaWdodDogZmFsc2UsIGluY2x1c2l2ZUxlZnQ6IGZhbHNlIH0pKVxuICAgICAgICBmcm9tID0gbmV3IENvZGVNaXJyb3IuUG9zKGZyb20ubGluZSArIDEsIDApXG4gICAgICB9XG4gICAgICB3aGlsZSAoZnJvbS5saW5lICE9PSB0by5saW5lKSB7XG4gICAgICAgIC8vIG1pZGRsZSBvZiBzZWxlY3Rpb24gaXMgYWx3YXlzIGEgd2hvbGUtbGluZSBzZWxlY3Rpb24uIFdlIGFkZCBhIHdpZGdldCBhdCB0aGUgZmlyc3QgcG9zaXRpb24gd2hpY2ggd2lsbCBmaWxsIHRoZSBiYWNrZ3JvdW5kLlxuICAgICAgICBzZWwucHVzaChjbS5zZXRCb29rbWFyayhuZXcgQ29kZU1pcnJvci5Qb3MoZnJvbS5saW5lLCAwKSwgeyB3aWRnZXQ6IGNyZWF0ZUVtcHR5TGluZVBsYWNlaG9sZGVyKHVzZXIuY29sb3IpIH0pKVxuICAgICAgICBmcm9tID0gbmV3IENvZGVNaXJyb3IuUG9zKGZyb20ubGluZSArIDEsIDApXG4gICAgICB9XG4gICAgICBzZWwucHVzaChjbS5tYXJrVGV4dChmcm9tLCB0bywgeyBjc3M6IGBiYWNrZ3JvdW5kLWNvbG9yOiAke3VzZXIuY29sb3J9NzA7YCwgaW5jbHVzaXZlUmlnaHQ6IGZhbHNlLCBpbmNsdXNpdmVMZWZ0OiBmYWxzZSB9KSlcbiAgICB9XG4gICAgLy8gb25seSByZW5kZXIgY2FyZXQgaWYgbm90IHRoZSBjb21wbGV0ZSBsYXN0IGxpbmUgd2FzIHNlbGVjdGVkIChpbiB0aGlzIGNhc2UgaGVhZHBvcy5jaCA9PT0gMClcbiAgICBjb25zdCBjYXJldCA9IHNlbC5sZW5ndGggPiAwICYmIHRvID09PSBoZWFkcG9zICYmIGhlYWRwb3MuY2ggPT09IDAgPyBudWxsIDogY20uc2V0Qm9va21hcmsoaGVhZHBvcywgeyB3aWRnZXQ6IGNhcmV0RWwsIGluc2VydExlZnQ6IHRydWUgfSlcbiAgICBjdXJzb3JzLnNldChjbGllbnRJZCwgeyBjYXJldCwgc2VsLCBhd0N1cnNvcjogY3Vyc29yIH0pXG4gIH1cbn1cblxuY29uc3QgY29kZW1pcnJvckN1cnNvckFjdGl2aXR5ID0gKHksIGNtLCB0eXBlLCBhd2FyZW5lc3MpID0+IHtcbiAgY29uc3QgYXcgPSBhd2FyZW5lc3MuZ2V0TG9jYWxTdGF0ZSgpXG4gIGlmICghY20uaGFzRm9jdXMoKSB8fCBhdyA9PSBudWxsIHx8ICFjbS5kaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudC5oYXNGb2N1cygpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgbmV3QW5jaG9yID0gWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbVR5cGVJbmRleCh0eXBlLCBjbS5pbmRleEZyb21Qb3MoY20uZ2V0Q3Vyc29yKCdhbmNob3InKSkpXG4gIGNvbnN0IG5ld0hlYWQgPSBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4KHR5cGUsIGNtLmluZGV4RnJvbVBvcyhjbS5nZXRDdXJzb3IoJ2hlYWQnKSkpXG4gIGxldCBjdXJyZW50QW5jaG9yID0gbnVsbFxuICBsZXQgY3VycmVudEhlYWQgPSBudWxsXG4gIGlmIChhdy5jdXJzb3IgIT0gbnVsbCkge1xuICAgIGN1cnJlbnRBbmNob3IgPSBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTihKU09OLnBhcnNlKGF3LmN1cnNvci5hbmNob3IpKVxuICAgIGN1cnJlbnRIZWFkID0gWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04oSlNPTi5wYXJzZShhdy5jdXJzb3IuaGVhZCkpXG4gIH1cbiAgaWYgKGF3LmN1cnNvciA9PSBudWxsIHx8ICFZLmNvbXBhcmVSZWxhdGl2ZVBvc2l0aW9ucyhjdXJyZW50QW5jaG9yLCBuZXdBbmNob3IpIHx8ICFZLmNvbXBhcmVSZWxhdGl2ZVBvc2l0aW9ucyhjdXJyZW50SGVhZCwgbmV3SGVhZCkpIHtcbiAgICBhd2FyZW5lc3Muc2V0TG9jYWxTdGF0ZUZpZWxkKCdjdXJzb3InLCB7XG4gICAgICBhbmNob3I6IEpTT04uc3RyaW5naWZ5KG5ld0FuY2hvciksXG4gICAgICBoZWFkOiBKU09OLnN0cmluZ2lmeShuZXdIZWFkKVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBBIGJpbmRpbmcgdGhhdCBiaW5kcyBhIFlUZXh0IHRvIGEgQ29kZU1pcnJvciBlZGl0b3IuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgeXRleHQgPSB5ZG9jdW1lbnQuZGVmaW5lKCdjb2RlbWlycm9yJywgWS5UZXh0KVxuICogICBjb25zdCBlZGl0b3IgPSBuZXcgQ29kZU1pcnJvcihkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY29udGFpbmVyJyksIHtcbiAqICAgICBtb2RlOiAnamF2YXNjcmlwdCcsXG4gKiAgICAgbGluZU51bWJlcnM6IHRydWVcbiAqICAgfSlcbiAqICAgY29uc3QgYmluZGluZyA9IG5ldyBDb2RlbWlycm9yQmluZGluZyh5dGV4dCwgZWRpdG9yKVxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIENvZGVtaXJyb3JCaW5kaW5nIGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1kuVGV4dH0gdGV4dFR5cGVcbiAgICogQHBhcmFtIHtpbXBvcnQoJ2NvZGVtaXJyb3InKS5FZGl0b3J9IGNvZGVNaXJyb3JcbiAgICogQHBhcmFtIHthbnkgfCBudWxsfSBbYXdhcmVuZXNzXVxuICAgKiBAcGFyYW0ge3sgeVVuZG9NYW5hZ2VyPzogWS5VbmRvTWFuYWdlciB9fSBbb3B0aW9uc11cbiAgICovXG4gIGNvbnN0cnVjdG9yICh0ZXh0VHlwZSwgY29kZU1pcnJvciwgYXdhcmVuZXNzID0gbnVsbCwgeyB5VW5kb01hbmFnZXIgPSBudWxsIH0gPSB7fSkge1xuICAgIHN1cGVyKClcbiAgICBjb25zdCBkb2MgPSB0ZXh0VHlwZS5kb2NcbiAgICBjb25zdCBjbURvYyA9IGNvZGVNaXJyb3IuZ2V0RG9jKClcbiAgICB0aGlzLmRvYyA9IGRvY1xuICAgIHRoaXMudHlwZSA9IHRleHRUeXBlXG4gICAgdGhpcy5jbSA9IGNvZGVNaXJyb3JcbiAgICB0aGlzLmNtRG9jID0gY21Eb2NcbiAgICB0aGlzLmF3YXJlbmVzcyA9IGF3YXJlbmVzcyB8fCBudWxsXG4gICAgdGhpcy55VW5kb01hbmFnZXIgPSB5VW5kb01hbmFnZXJcbiAgICB0aGlzLl9vblN0YWNrSXRlbUFkZGVkID0gKHsgc3RhY2tJdGVtLCBjaGFuZ2VkUGFyZW50VHlwZXMgfSkgPT4ge1xuICAgICAgLy8gb25seSBzdG9yZSBtZXRhZGF0YSBpZiB0aGlzIHR5cGUgd2FzIGFmZmVjdGVkXG4gICAgICBpZiAoY2hhbmdlZFBhcmVudFR5cGVzLmhhcyh0ZXh0VHlwZSkgJiYgdGhpcy5fYmVmb3JlQ2hhbmdlU2VsZWN0aW9uKSB7XG4gICAgICAgIHN0YWNrSXRlbS5tZXRhLnNldCh0aGlzLCB0aGlzLl9iZWZvcmVDaGFuZ2VTZWxlY3Rpb24pXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX29uU3RhY2tJdGVtUG9wcGVkID0gKHsgc3RhY2tJdGVtIH0pID0+IHtcbiAgICAgIGNvbnN0IHNlbCA9IHN0YWNrSXRlbS5tZXRhLmdldCh0aGlzKVxuICAgICAgaWYgKHNlbCkge1xuICAgICAgICBjb25zdCBhbmNob3IgPSBZLmNyZWF0ZUFic29sdXRlUG9zaXRpb25Gcm9tUmVsYXRpdmVQb3NpdGlvbihzZWwuYW5jaG9yLCBkb2MpLmluZGV4XG4gICAgICAgIGNvbnN0IGhlYWQgPSBZLmNyZWF0ZUFic29sdXRlUG9zaXRpb25Gcm9tUmVsYXRpdmVQb3NpdGlvbihzZWwuaGVhZCwgZG9jKS5pbmRleFxuICAgICAgICBjb2RlTWlycm9yLnNldFNlbGVjdGlvbihjb2RlTWlycm9yLnBvc0Zyb21JbmRleChhbmNob3IpLCBjb2RlTWlycm9yLnBvc0Zyb21JbmRleChoZWFkKSlcbiAgICAgICAgdGhpcy5fYmVmb3JlQ2hhbmdlKClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHlVbmRvTWFuYWdlcikge1xuICAgICAgeVVuZG9NYW5hZ2VyLnRyYWNrZWRPcmlnaW5zLmFkZCh0aGlzKSAvLyB0cmFjayBjaGFuZ2VzIHBlcmZvcm1lZCBieSB0aGlzIGVkaXRvciBiaW5kaW5nXG4gICAgICBjb25zdCBlZGl0b3JVbmRvID0gY20gPT4ge1xuICAgICAgICAvLyBLZXltYXBzIGFsd2F5cyBzdGFydCB3aXRoIGFuIGFjdGl2ZSBvcGVyYXRpb24uXG4gICAgICAgIC8vIEVuZCB0aGUgY3VycmVudCBvcGVyYXRpb24gc28gdGhhdCB0aGUgZXZlbnQgaXMgZmlyZWQgYXQgdGhlIGNvcnJlY3QgbW9tZW50LlxuICAgICAgICAvLyBAdG9kbyBjaGVjayBjbS5jdXJPcCBpbiB0eXBlTGlzdGVuZXIgYW5kIGVuZE9wZXJhdGlvbiBhbHdheXMuXG4gICAgICAgIGNtLmVuZE9wZXJhdGlvbigpXG4gICAgICAgIHlVbmRvTWFuYWdlci51bmRvKClcbiAgICAgICAgY20uc3RhcnRPcGVyYXRpb24oKVxuICAgICAgfVxuICAgICAgY29uc3QgZWRpdG9yUmVkbyA9IGNtID0+IHtcbiAgICAgICAgY20uZW5kT3BlcmF0aW9uKClcbiAgICAgICAgeVVuZG9NYW5hZ2VyLnJlZG8oKVxuICAgICAgICBjbS5zdGFydE9wZXJhdGlvbigpXG4gICAgICB9XG4gICAgICBjb2RlTWlycm9yLmFkZEtleU1hcCh7XG4gICAgICAgIC8vIHBjXG4gICAgICAgICdDdHJsLVonOiBlZGl0b3JVbmRvLFxuICAgICAgICAnU2hpZnQtQ3RybC1aJzogZWRpdG9yUmVkbyxcbiAgICAgICAgJ0N0cmwtWSc6IGVkaXRvclJlZG8sXG4gICAgICAgIC8vIG1hY1xuICAgICAgICAnQ21kLVonOiBlZGl0b3JVbmRvLFxuICAgICAgICAnU2hpZnQtQ21kLVonOiBlZGl0b3JSZWRvLFxuICAgICAgICAnQ21kLVknOiBlZGl0b3JSZWRvXG4gICAgICB9KVxuXG4gICAgICB5VW5kb01hbmFnZXIub24oJ3N0YWNrLWl0ZW0tYWRkZWQnLCB0aGlzLl9vblN0YWNrSXRlbUFkZGVkKVxuICAgICAgeVVuZG9NYW5hZ2VyLm9uKCdzdGFjay1pdGVtLXBvcHBlZCcsIHRoaXMuX29uU3RhY2tJdGVtUG9wcGVkKVxuICAgIH1cblxuICAgIHRoaXMuX211eCA9IGNyZWF0ZU11dGV4KClcbiAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZVxuICAgIGNtRG9jLnNldFZhbHVlKHRleHRUeXBlLnRvU3RyaW5nKCkpXG4gICAgLy8gb2JzZXJ2ZSB0eXBlIGFuZCB0YXJnZXRcbiAgICB0aGlzLl90eXBlT2JzZXJ2ZXIgPSBldmVudCA9PiB0eXBlT2JzZXJ2ZXIodGhpcywgZXZlbnQpXG4gICAgdGhpcy5fdGFyZ2V0T2JzZXJ2ZXIgPSAoaW5zdGFuY2UsIGNoYW5nZXMpID0+IHtcbiAgICAgIGlmIChpbnN0YW5jZS5nZXREb2MoKSA9PT0gY21Eb2MpIHtcbiAgICAgICAgdGFyZ2V0T2JzZXJ2ZXIodGhpcywgY2hhbmdlcylcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fY3Vyc29ycyA9IG5ldyBNYXAoKVxuICAgIHRoaXMuX2NoYW5nZWRDdXJzb3JzID0gbmV3IFNldCgpXG4gICAgdGhpcy5fZGVib3VuY2VDdXJzb3JFdmVudCA9IGV2ZW50bG9vcC5jcmVhdGVEZWJvdW5jZXIoMTApXG4gICAgdGhpcy5fYXdhcmVuZXNzTGlzdGVuZXIgPSBldmVudCA9PiB7XG4gICAgICBpZiAoY29kZU1pcnJvci5nZXREb2MoKSAhPT0gY21Eb2MpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCBmID0gY2xpZW50SWQgPT4ge1xuICAgICAgICBpZiAoY2xpZW50SWQgIT09IGRvYy5jbGllbnRJRCkge1xuICAgICAgICAgIHRoaXMuX2NoYW5nZWRDdXJzb3JzLmFkZChjbGllbnRJZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXZlbnQuYWRkZWQuZm9yRWFjaChmKVxuICAgICAgZXZlbnQucmVtb3ZlZC5mb3JFYWNoKGYpXG4gICAgICBldmVudC51cGRhdGVkLmZvckVhY2goZilcbiAgICAgIGlmICh0aGlzLl9jaGFuZ2VkQ3Vyc29ycy5zaXplID4gMCkge1xuICAgICAgICB0aGlzLl9kZWJvdW5jZUN1cnNvckV2ZW50KCgpID0+IHtcbiAgICAgICAgICB0aGlzLl9jaGFuZ2VkQ3Vyc29ycy5mb3JFYWNoKGNsaWVudElkID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZVJlbW90ZVNlbGVjdGlvbihkb2MsIGNvZGVNaXJyb3IsIHRleHRUeXBlLCB0aGlzLl9jdXJzb3JzLCBjbGllbnRJZCwgYXdhcmVuZXNzKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgdGhpcy5fY2hhbmdlZEN1cnNvcnMuY2xlYXIoKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9wZW5kaW5nQ3Vyc29yRXZlbnQgPSBmYWxzZVxuICAgIHRoaXMuX2N1cnNvckxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgaWYgKGNvZGVNaXJyb3IuZ2V0RG9jKCkgPT09IGNtRG9jKSB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdDdXJzb3JFdmVudCA9IHRydWVcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdDdXJzb3JFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0N1cnNvckV2ZW50ID0gZmFsc2VcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY3Vyc29yQWN0aXZpdHknLCBbY29kZU1pcnJvcl0pXG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm9uKCdjdXJzb3JBY3Rpdml0eScsICgpID0+IHtcbiAgICAgIGNvZGVtaXJyb3JDdXJzb3JBY3Rpdml0eShkb2MsIGNvZGVNaXJyb3IsIHRleHRUeXBlLCBhd2FyZW5lc3MpXG4gICAgfSlcbiAgICB0aGlzLl9ibHVyTGlzdGVlciA9ICgpID0+IGF3YXJlbmVzcy5zZXRMb2NhbFN0YXRlRmllbGQoJ2N1cnNvcicsIG51bGwpXG5cbiAgICB0ZXh0VHlwZS5vYnNlcnZlKHRoaXMuX3R5cGVPYnNlcnZlcilcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29kZU1pcnJvci5vbignY2hhbmdlcycsIHRoaXMuX3RhcmdldE9ic2VydmVyKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHt7IGFuY2hvcjogWS5SZWxhdGl2ZVBvc2l0aW9uLCBoZWFkOiBZLlJlbGF0aXZlUG9zaXRpb24gfSB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fYmVmb3JlQ2hhbmdlU2VsZWN0aW9uID0gbnVsbFxuICAgIHRoaXMuX2JlZm9yZUNoYW5nZSA9ICgpID0+IHtcbiAgICAgIC8vIHVwZGF0ZSB0aGUgdGhlIGJlZm9yZUNoYW5nZVNlbGVjdGlvbiB0aGF0IGlzIHN0b3JlZCBiZWZvciBlYWNoIGNoYW5nZSB0byB0aGUgZWRpdG9yIChleGNlcHQgd2hlbiBhcHBseWluZyByZW1vdGUgY2hhbmdlcylcbiAgICAgIHRoaXMuX211eCgoKSA9PiB7XG4gICAgICAgIC8vIHN0b3JlIHRoZSBzZWxlY3Rpb24gYmVmb3JlIHRoZSBjaGFuZ2UgaXMgYXBwbGllZCBzbyB3ZSBjYW4gcmVzdG9yZSBpdCB3aXRoIHRoZSB1bmRvIG1hbmFnZXIuXG4gICAgICAgIGNvbnN0IGFuY2hvciA9IFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21UeXBlSW5kZXgodGV4dFR5cGUsIGNvZGVNaXJyb3IuaW5kZXhGcm9tUG9zKGNvZGVNaXJyb3IuZ2V0Q3Vyc29yKCdhbmNob3InKSkpXG4gICAgICAgIGNvbnN0IGhlYWQgPSBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4KHRleHRUeXBlLCBjb2RlTWlycm9yLmluZGV4RnJvbVBvcyhjb2RlTWlycm9yLmdldEN1cnNvcignaGVhZCcpKSlcbiAgICAgICAgdGhpcy5fYmVmb3JlQ2hhbmdlU2VsZWN0aW9uID0geyBhbmNob3IsIGhlYWQgfVxuICAgICAgfSlcbiAgICB9XG4gICAgY29kZU1pcnJvci5vbignYmVmb3JlQ2hhbmdlJywgdGhpcy5fYmVmb3JlQ2hhbmdlKVxuICAgIGlmIChhd2FyZW5lc3MpIHtcbiAgICAgIGNvZGVNaXJyb3Iub24oJ3N3YXBEb2MnLCB0aGlzLl9ibHVyTGlzdGVlcilcbiAgICAgIGF3YXJlbmVzcy5vbignY2hhbmdlJywgdGhpcy5fYXdhcmVuZXNzTGlzdGVuZXIpXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb2RlTWlycm9yLm9uKCdjdXJzb3JBY3Rpdml0eScsIHRoaXMuX2N1cnNvckxpc3RlbmVyKVxuICAgICAgY29kZU1pcnJvci5vbignYmx1cicsIHRoaXMuX2JsdXJMaXN0ZWVyKVxuICAgICAgY29kZU1pcnJvci5vbignZm9jdXMnLCB0aGlzLl9jdXJzb3JMaXN0ZW5lcilcbiAgICB9XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLnR5cGUudW5vYnNlcnZlKHRoaXMuX3R5cGVPYnNlcnZlcilcbiAgICB0aGlzLmNtLm9mZignc3dhcERvYycsIHRoaXMuX2JsdXJMaXN0ZWVyKVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmNtLm9mZignY2hhbmdlcycsIHRoaXMuX3RhcmdldE9ic2VydmVyKVxuICAgIHRoaXMuY20ub2ZmKCdiZWZvcmVDaGFuZ2UnLCB0aGlzLl9iZWZvcmVDaGFuZ2UpXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuY20ub2ZmKCdjdXJzb3JBY3Rpdml0eScsIHRoaXMuX2N1cnNvckxpc3RlbmVyKVxuICAgIHRoaXMuY20ub2ZmKCdmb2N1cycsIHRoaXMuX2N1cnNvckxpc3RlbmVyKVxuICAgIHRoaXMuY20ub2ZmKCdibHVyJywgdGhpcy5fYmx1ckxpc3RlZXIpXG4gICAgaWYgKHRoaXMuYXdhcmVuZXNzKSB7XG4gICAgICB0aGlzLmF3YXJlbmVzcy5vZmYoJ2NoYW5nZScsIHRoaXMuX2F3YXJlbmVzc0xpc3RlbmVyKVxuICAgIH1cbiAgICBpZiAodGhpcy55VW5kb01hbmFnZXIpIHtcbiAgICAgIHRoaXMueVVuZG9NYW5hZ2VyLm9mZignc3RhY2staXRlbS1hZGRlZCcsIHRoaXMuX29uU3RhY2tJdGVtQWRkZWQpXG4gICAgICB0aGlzLnlVbmRvTWFuYWdlci5vZmYoJ3N0YWNrLWl0ZW0tcG9wcGVkJywgdGhpcy5fb25TdGFja0l0ZW1Qb3BwZWQpXG4gICAgICB0aGlzLnlVbmRvTWFuYWdlci50cmFja2VkT3JpZ2lucy5kZWxldGUodGhpcylcbiAgICB9XG4gICAgdGhpcy50eXBlID0gbnVsbFxuICAgIHRoaXMuY20gPSBudWxsXG4gICAgdGhpcy5jbURvYyA9IG51bGxcbiAgICBzdXBlci5kZXN0cm95KClcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQ29kZU1pcnJvckJpbmRpbmcgPSBDb2RlbWlycm9yQmluZGluZ1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-codemirror/src/y-codemirror.js\n");

/***/ })

};
;